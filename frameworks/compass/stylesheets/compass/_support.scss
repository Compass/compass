// The list of browsers you want to support.
// Defaults to all.
$supported-browsers: browsers() !default;

// The browser usage threshold for features that gracefully degrade
// Defaults to 1 user in 1,000.
$graceful-usage-threshold: 0.1 !default;

// The browser usage threshold for features that cannot degrade gracefully
// Defaults to 1 user in 10,000.
$critical-usage-threshold: 0.01 !default;

// Set this to true to generate comments that will explain why a prefix was included or omitted.
$debug-browser-support: false !default;

// Minimum browser versions that must be supported.
// The keys of this map are any valid browser according to `browsers()`.
// The values of this map are the min version that is valid for that browser
// according to `browser-versions($browser)`
$browser-minimum-versions: (
  'chrome':  null,
  'firefox': null,
  'ie':      null,
  'safari':  null,
  'opera':   null
) !default;

// When a prefix is in a selector or directive scope, this is set to the current prefix value.
$current-prefix: null;

// When in a context that only exists in a particular version
// this variable is set to those versions.
$current-browser-minimum-versions: ();

// Check if the browser is in scope given the current prefix minimums.
@function browser-out-of-scope($browser, $version: null) {
  @if not ($current-prefix == null or $current-prefix == browser-prefix($browser)) {
    @if $debug-browser-support {
      @return "The #{$browser} #{$version} is incompatible with #{$current-prefix}."
    } @else {
      @return true;
    }
  }
  $current-min: map-get($current-browser-minimum-versions, $browser);
  @if not ($version and $current-min) {
    // We don't have any versions to compare
    @return false;
  } @else {
    // If the version is less than the current min, it is not supported
    $too-old: compare-browser-versions($browser, $version, $current-min) < 0;
    @if $too-old {
      @if $debug-browser-support {
        @return "The current scope only works with #{$browser} #{$current-min} or greater.";
      } @else {
        @return true;
      }
    } @else {
      @return false;
    }
  }
}

// Check whether the browser is supported according to the declared minimum support
// and usage thresholds.
@function support-legacy-browser($browser, $version, $threshold: $critical-usage-threshold) {
  // Check agaist usage stats and declared minimums
  $min-version: map-get($browser-minimum-versions, $browser);
  @return omitted-usage($browser, $version) > $threshold or
          ($min-version and compare-browser-versions($browser, $version, $min-version) >= 0);
}

// Include content for a legacy browser

// Version can be a single version string or a list of versions ordered from oldest to newest.
@mixin for-legacy-browser($browser, $version, $threshold: $critical-usage-threshold) {
  $latest-version: nth($version, -1);
  @if not browser-out-of-scope($browser, $latest-version) and
      support-legacy-browser($browser, $latest-version, $threshold)
  {
    @if $debug-browser-support {
      /* Content for #{$browser} #{$version}.
      Min version: #{map-get($browser-minimum-versions, $browser)}.
      User threshold to keep: #{$threshold}%. If #{$browser} #{$version} and below are omitted: #{omitted-usage($browser, $version)}%. */
    }
    @content;
  } @else if $debug-browser-support and browser-out-of-scope($browser, $latest-version) {
    /* Content for #{$browser} #{$version} omitted.
       Not allowed in the current scope: #{browser-out-of-scope($browser, $latest-version)} */
  } @else if $debug-browser-support and not support-legacy-browser($browser, $latest-version, $threshold) {
    @if omitted-usage($browser, $version) > $threshold {
      /* Content for #{$browser} #{$version} omitted.
         User threshold to keep: #{$threshold}%. If #{$browser} #{$version} and below are omitted: #{omitted-usage($browser, $version)}%. */
    } @else {
      /* Content for #{$browser} #{$version} omitted.
         Minimum support is #{map-get($browser-minimum-versions, $browser)}. */
    }
  }
}

// If there's a prefix context in scope, this will only output the content if the prefix matches.
// Otherwise, sets the current prefix scope and outputs the content.
@mixin with-prefix($prefix) {
  @if $current-prefix {
    @if $current-prefix == $prefix {
      @content;
    } @else if $debug-browser-support {
      /* Omitting content for #{$prefix} because #{$current-prefix} is already in scope. */
    }
  } @else {
    $current-prefix: $prefix;
    @content;
    $current-prefix: null;
  }
}

// Yields to the mixin content once for each prefix required.
// The current prefix is set to the $current-prefix global for use by the included content.
// Also yields to the content once with $current-prefix set to null for the official version
// as long as there's not already a prefix in scope.
@mixin with-each-prefix($capability, $threshold) {
  @each $prefix in browser-prefixes($supported-browsers) {
    $should-use-prefix: use-prefix($prefix, $capability, $threshold);

    @if $should-use-prefix {
      @if $debug-browser-support and type-of($should-use-prefix) == list {
        /* Capability #{$capability} is prefixed with #{$prefix} because #{$should-use-prefix} is required. */
      } @else if $debug-browser-support and type-of($should-use-prefix) == number {
        /* Capability #{$capability} is prefixed with #{$prefix} because omitting it would affect #{$should-use-prefix}% of users and the threshold is #{$threshold}%. */
      }
      @include with-prefix($prefix) {
        @include with-browser-minimums($capability) {
          @content;
        }
      }
    }
  }
  @if not $current-prefix {
    @include with-browser-minimums($capability) {
      @content;
    }
  } @else if $debug-browser-support {
    /* Not including prefix-free content for #{$capability} because the #{$current-prefix} prefix is in scope. */
  }
}

// If passed a map, that will be the new browser minimums.
// Otherwise a minimum map will be created based on the given capability and prefix
// using the `browser-minimums($capability, $prefix)` function.
@mixin with-browser-minimums($capability, $prefix: $current-prefix) {
  @if type-of($capability) == map {
    $old-minimums: $current-browser-minimum-versions;
    $current-browser-minimum-versions: $capability;
    @content;
    $current-browser-minimum-versions: $old-minimums;
  } @else {
    $old-minimums: $current-browser-minimum-versions;
    $current-browser-minimum-versions: browser-minimums($capability, $prefix);
    @content;
    $current-browser-minimum-versions: $old-minimums;
  }
}

// Returns true if the prefixed usage stats for the capability exceed the threshold
// or if the minimum version for a supported browser would require a prefix for the capability.
@function use-prefix($prefix, $capability, $threshold) {
  $usage: prefix-usage($prefix, $capability);
  @if $usage > $threshold {
    @return $usage;
  } @else {
    @each $browser in browsers($prefix) {
      @if index($supported-browsers, $browser) {
        $min-version: map-get($browser-minimum-versions, $browser);
        @if $min-version and browser-requires-prefix($browser, $min-version, $capability) {
          @return $browser $min-version;
        }
      }
    }
  }
  @return false;
}

// Output a property and value using the current prefix.
// It will be unprefixed if $current-prefix is null.
@mixin prefix-prop($property, $value) {
  #{$current-prefix}#{if($current-prefix, '-', null)}#{$property}: $value;
}

// Emit a set of properties with the prefix governed by the capability and usage threshold given.
//
// Example:
//
//     @include prefixed-properties(css-animation, $animation-support-threshold,
//       (animation-name: foo, animation-duration: 2s)
//     );
@mixin prefixed-properties($capability, $threshold, $properties) {
  @include with-each-prefix($capability, $threshold) {
    @each $prop, $value in $properties {
      @include prefix-prop($prop, $value);
    }
  }
}


// @private
@function warn-about-old-variables() {
  $old-variables-in-use: ();
  @each $old-variable-name in
        (legacy-support-for-ie, legacy-support-for-ie6, legacy-support-for-ie7,
         legacy-support-for-ie8, legacy-support-for-mozilla, legacy-support-for-webkit,
         experimental-support-for-mozilla, experimental-support-for-webkit,
         experimental-support-for-opera, experimental-support-for-microsoft,
         experimental-support-for-khtml, experimental-support-for-svg)
  {
    @if global-variable-exists($old-variable-name) {
      $old-variables-in-use: append($old-variables-in-use,
                                    unquote("$#{$old-variable-name}"), comma);
    }
  }
  @if length($old-variables-in-use) > 0 {
    @warn "Compass has changed how browser support is configured. " +
          "See the CHANGELOG for more details. The following configuration variables " +
          "are no longer supported: #{$old-variables-in-use}."
  }
  @return $old-variables-in-use;
}

// @private
@function warn-about-pie-removal() {
  @if global-variable-exists(experimental-support-for-pie) {
    @warn "Compass no longer supports css3pie.";
  }
  @return true;
}

// Enable browser support debugging within the content block.
// Or you can enable it for the whole stylesheet by setting `$debug-browser-support` to true.
@mixin with-browser-support-debugging {
  $current-status: $debug-browser-support;
  $debug-browser-support: true;
  @content;
  $debug-browser-support: $current-status;
}

// @private
$old-variable-warnings-issued: warn-about-old-variables() !default;

// @private
$pie-removal-warnging-issued: warn-about-pie-removal() !default;

// @private
@function warn-about-useless-prefix-arguments($moz: null, $webkit: null, $o: null, $khtml: null, $official: null) {
  @if $moz != null or $webkit != null or $o != null or $khtml != null or $official != null {
    @warn "Browser prefix arguments to this mixin are no longer used and " +
          "will be removed in the next release.";
  }
  @return true;
}
